<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Dynamic Programming: Unique Paths Grid</title>    <!-- Load Tailwind CSS for modern, responsive styling -->    <script src="https://cdn.tailwindcss.com"></script>    <style>        /* Custom styles for aesthetic */        body {            font-family: 'Inter', sans-serif;            background-color: #f0f4f8;        }        .card {            box-shadow: 0 10px 25px -5px rgba(45, 55, 72, 0.1), 0 4px 6px -2px rgba(45, 55, 72, 0.05);            transition: all 0.3s ease;        }        .grid-container {            display: grid;            grid-template-columns: repeat(var(--cols), 1fr);            gap: 1px;            border: 1px solid #cbd5e0;            max-width: 100%;            overflow-x: auto;            margin-top: 1rem;            border-radius: 0.5rem;        }        .grid-cell {            background-color: #ffffff;            border: 1px solid #e2e8f0;            display: flex;            align-items: center;            justify-content: center;            padding: 0.5rem;            min-width: 40px; /* Ensures visibility on small screens */            aspect-ratio: 1 / 1; /* Makes cells square */            font-weight: 600;        }        /* Highlight Start and End Cells */        .start-cell { background-color: #d1fae5; color: #065f46; font-weight: bold; }        .end-cell { background-color: #fee2e2; color: #991b1b; font-weight: bold; }    </style></head><body class="min-h-screen flex items-center justify-center p-4">    <div class="card bg-white p-6 md:p-10 rounded-xl w-full max-w-4xl">        <h1 class="text-3xl font-extrabold text-center text-gray-800 mb-2">            ðŸ¤– Unique Paths DP Visualizer        </h1>        <p class="text-center text-gray-500 mb-6">            Calculate the number of unique paths a robot can take from the top-left (Start) to the bottom-right (End) of an M x N grid.        </p>        <!-- Input Form -->        <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 mb-6">            <div class="flex-1">                <label for="rows" class="block text-sm font-medium text-gray-700 mb-1">Rows (M)</label>                <input type="number" id="rows" value="3" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" min="1" max="50">            </div>            <div class="flex-1">                <label for="cols" class="block text-sm font-medium text-gray-700 mb-1">Columns (N)</label>                <input type="number" id="cols" value="7" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" min="1" max="50">            </div>        </div>        <div class="space-y-4">            <button onclick="calculateUniquePaths()" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 rounded-lg transition duration-150 ease-in-out">                Calculate Paths & Visualize            </button>            <button onclick="generateExplanation()" id="explainButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-semibold py-3 rounded-lg transition duration-150 ease-in-out">                âœ¨ Explain DP Concept            </button>        </div>        <!-- LLM Explanation Output -->        <div id="explanationOutput" class="mt-8 p-4 bg-gray-100 rounded-lg border border-gray-300 hidden">            <h2 class="text-xl font-bold text-gray-700 mb-2">Dynamic Programming Insight</h2>            <div id="explanationText" class="text-gray-600 prose max-w-none"></div>            <div id="explanationLoader" class="hidden text-center mt-4">                <div class="spinner border-t-4 border-b-4 border-green-500 rounded-full w-6 h-6 inline-block animate-spin"></div>                <p class="text-sm text-gray-500 mt-2">Generating explanation...</p>            </div>        </div>        <!-- Results Display -->        <div id="results" class="mt-8 space-y-4 hidden">            <div id="error-message" class="text-red-600 font-medium hidden mb-4 p-3 bg-red-100 rounded-lg"></div>            <div class="bg-indigo-50 p-4 rounded-lg flex flex-col md:flex-row justify-between items-center border border-indigo-200">                <p class="text-lg font-medium text-indigo-800 mb-2 md:mb-0">Total Unique Paths Found:</p>                <p id="pathsOutput" class="text-4xl font-extrabold text-indigo-600">--</p>            </div>            <h2 class="text-xl font-bold text-gray-700 pt-4">Dynamic Programming Grid (Visualization)</h2>            <p class="text-sm text-gray-500 mb-2">Each cell shows the number of unique paths to reach that point from the Start (0, 0).</p>            <!-- Grid output area -->            <div id="gridOutput" class="pb-4">                <!-- Grid will be injected here by JavaScript -->            </div>        </div>    </div>    <script>        // --- LLM API Configuration and Utility Functions ---        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";        const apiKey = ""; // API key will be provided by the environment        /**         * Generic fetch utility with exponential backoff for API robustness.         */        async function exponentialBackoffFetch(url, options, maxRetries = 5, delay = 1000) {            for (let i = 0; i < maxRetries; i++) {                try {                    const response = await fetch(url, options);                    if (response.ok) {                        return response;                    }                    if (response.status === 429) { // Rate limit or transient error                        console.warn(`Rate limit hit. Retrying in ${delay / 1000}s...`);                        await new Promise(resolve => setTimeout(resolve, delay));                        delay *= 2; // Exponential increase                    } else {                        throw new Error(`API Error: ${response.statusText}`);                    }                } catch (error) {                    if (i === maxRetries - 1) throw error;                    console.error("Fetch attempt failed, retrying:", error.message);                    await new Promise(resolve => setTimeout(resolve, delay));                    delay *= 2;                }            }        }        /**         * Calls the Gemini API to get a conceptual explanation.         */        async function callGeminiAPI(userQuery) {            const systemPrompt = "You are an expert DSA tutor. Provide a concise, educational explanation of the Dynamic Programming concept as applied to the Unique Paths problem. Explain the base cases and the recurrence relation using LaTeX syntax for clarity. The tone should be encouraging and clear.";                        const payload = {                contents: [{ parts: [{ text: userQuery }] }],                systemInstruction: { parts: [{ text: systemPrompt }] },            };            const options = {                method: 'POST',                headers: { 'Content-Type': 'application/json' },                body: JSON.stringify(payload),            };            try {                const response = await exponentialBackoffFetch(`${API_URL}?key=${apiKey}`, options);                const result = await response.json();                                const candidate = result.candidates?.[0];                if (candidate && candidate.content?.parts?.[0]?.text) {                    return candidate.content.parts[0].text;                } else {                    console.error("Gemini API response format invalid:", result);                    return "Error: Could not retrieve the explanation from the AI.";                }            } catch (error) {                console.error("Error calling Gemini API:", error);                return "Error: Failed to connect to the AI service.";            }        }        /**         * Function to generate and display the explanation.         */        async function generateExplanation() {            const explainButton = document.getElementById('explainButton');            const explanationOutput = document.getElementById('explanationOutput');            const explanationText = document.getElementById('explanationText');            const explanationLoader = document.getElementById('explanationLoader');                        explanationOutput.classList.remove('hidden');            explanationText.innerHTML = '';            explanationLoader.classList.remove('hidden');            explainButton.disabled = true;            const m = parseInt(document.getElementById('rows').value);            const n = parseInt(document.getElementById('cols').value);                        const userQuery = `Explain the Dynamic Programming solution for the Unique Paths problem on a ${m}x${n} grid.`;            const explanation = await callGeminiAPI(userQuery);                        // Basic Markdown to HTML conversion for rendering            let htmlContent = explanation;            // Convert $$ math blocks to use the display block class            htmlContent = htmlContent.replace(/\$\$(.*?)\$\$/gs, (match, p1) =>                 `<div class="text-lg my-3 p-2 bg-gray-200 rounded-md overflow-x-auto">$$${p1.trim()}$$</div>`            );                        explanationText.innerHTML = htmlContent;            explanationLoader.classList.add('hidden');            explainButton.disabled = false;        }        // --- Original DP Logic and Visualization Functions ---        /**         * Dynamic Programming solution for Unique Paths in an M x N grid.         * The robot can only move down or right.         */        function uniquePathsDP(m, n) {            // PK: Initializing DP table for performance demonstration                        // Create a 2D array (m rows, n columns) and initialize with 0            const dp = Array(m).fill(0).map(() => Array(n).fill(0));            // Base Cases:            // 1. All cells in the first column (i, 0) have only 1 unique path (move down).            for (let i = 0; i < m; i++) {                dp[i][0] = 1;            }            // 2. All cells in the first row (0, j) have only 1 unique path (move right).            for (let j = 0; j < n; j++) {                dp[0][j] = 1;            }            // DP Recurrence Relation:            // The number of paths to reach (i, j) is the sum of paths from the cell above (i-1, j)            // and the cell to the left (i, j-1).            for (let i = 1; i < m; i++) {                for (let j = 1; j < n; j++) {                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];                }            }            // The result is the value at the bottom-right corner.            return { result: dp[m - 1][n - 1], dpTable: dp };        }        /**         * Main function triggered by the button click.         */        function calculateUniquePaths() {            const rowsInput = document.getElementById('rows');            const colsInput = document.getElementById('cols');            const pathsOutput = document.getElementById('pathsOutput');            const resultsDiv = document.getElementById('results');            const errorDiv = document.getElementById('error-message');            const gridOutput = document.getElementById('gridOutput');                        errorDiv.classList.add('hidden');            resultsDiv.classList.add('hidden');                        // 1. Validate and Parse Inputs            const m = parseInt(rowsInput.value);            const n = parseInt(colsInput.value);            if (isNaN(m) || isNaN(n) || m <= 0 || n <= 0 || m > 50 || n > 50) {                errorDiv.textContent = "Please enter valid dimensions (Rows M and Columns N) between 1 and 50.";                errorDiv.classList.remove('hidden');                return;            }            // 2. Run the DP Algorithm            const { result, dpTable } = uniquePathsDP(m, n);            // 3. Display Results            pathsOutput.textContent = result.toLocaleString();            resultsDiv.classList.remove('hidden');            // 4. Render DP Grid            renderDPGrid(m, n, dpTable, gridOutput);        }        /**         * Renders the DP grid for visualization.         */        function renderDPGrid(m, n, dpTable, container) {            // Set CSS variables for grid layout            container.style.setProperty('--cols', n);            container.className = 'grid-container';            container.innerHTML = ''; // Clear previous grid            for (let i = 0; i < m; i++) {                for (let j = 0; j < n; j++) {                    const cell = document.createElement('div');                    cell.className = 'grid-cell';                    cell.textContent = dpTable[i][j].toLocaleString();                    // Highlight start and end cells                    if (i === 0 && j === 0) {                        cell.classList.add('start-cell');                        cell.textContent = 'Start (1)';                    } else if (i === m - 1 && j === n - 1) {                        cell.classList.add('end-cell');                        cell.textContent = dpTable[i][j].toLocaleString(); // Show final result                    }                                        container.appendChild(cell);                }            }        }                // Run initial calculation on load for a clean starting state        window.onload = calculateUniquePaths;    </script>    <!-- MathJax for rendering LaTeX equations -->    <script>        // Use a slight delay to ensure the explanation is loaded before MathJax processes it.        function loadMathJax() {            if (window.MathJax) {                MathJax.typeset();            }        }                // Wait for the LLM output to appear, then load/typeset MathJax        const observer = new MutationObserver((mutationsList, observer) => {            const explanationText = document.getElementById('explanationText');            if (explanationText.innerHTML.trim() !== '' && explanationText.innerHTML.includes('$$')) {                // Load MathJax if not present                if (!window.MathJax) {                    const script = document.createElement('script');                    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';                    script.onload = () => {                        window.MathJax.startup.promise.then(loadMathJax);                    };                    document.head.appendChild(script);                } else {                    loadMathJax();                }            }        });        observer.observe(document.getElementById('explanationOutput'), { childList: true, subtree: true });    </script></body></html>